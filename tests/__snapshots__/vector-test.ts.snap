// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`vector-tile works 1`] = `
"import {Reader, Writer} from 'protobufjs';


export function decodeValue(reader: Reader, length?: number): Value {
  let end = length === undefined ? reader.len : reader.pos + length;
  const message = {} as Value;
  while (reader.pos < end) {
    const tag = reader.uint32();
    switch (tag >>> 3) {
      case 1:
      message.string_value = reader.string();
      break;
      case 2:
      message.float_value = reader.float();
      break;
      case 3:
      message.double_value = reader.double();
      break;
      case 4:
      message.int_value = reader.int64();
      break;
      case 5:
      message.uint_value = reader.uint64();
      break;
      case 6:
      message.sint_value = reader.sint64();
      break;
      case 7:
      message.bool_value = reader.bool();
      break;
      default:
      reader.skipType(tag & 7);
      break;
    }
  }
  return message;
}

export function encodeValue(message: Value, writer: Writer = new Writer()): Writer {
  writer.uint32(10).string(message.string_value);
  writer.uint32(21).float(message.float_value);
  writer.uint32(25).double(message.double_value);
  writer.uint32(32).int64(message.int_value);
  writer.uint32(40).uint64(message.uint_value);
  writer.uint32(48).sint64(message.sint_value);
  writer.uint32(56).bool(message.bool_value);
  return writer;
}

export interface Tile_Value {

  string_value: string;

  float_value: number;

  double_value: number;

  int_value: number;

  uint_value: number;

  sint_value: number;

  bool_value: boolean;

}

export function decodeFeature(reader: Reader, length?: number): Feature {
  let end = length === undefined ? reader.len : reader.pos + length;
  const message = {} as Feature;
  while (reader.pos < end) {
    const tag = reader.uint32();
    switch (tag >>> 3) {
      case 1:
      message.id = reader.uint64();
      break;
      case 2:
      message.tags = reader.uint32();
      break;
      case 3:
      message.type = reader.int32();
      break;
      case 4:
      message.geometry = reader.uint32();
      break;
      default:
      reader.skipType(tag & 7);
      break;
    }
  }
  return message;
}

export function encodeFeature(message: Feature, writer: Writer = new Writer()): Writer {
  writer.uint32(8).uint64(message.id);
  writer.uint32(16).uint32(message.tags);
  writer.uint32(24).int32(message.type);
  writer.uint32(32).uint32(message.geometry);
  return writer;
}

export interface Tile_Feature {

  id: number;

  tags: Array<number>;

  type: Tile_GeomType;

  geometry: Array<number>;

}

export function decodeLayer(reader: Reader, length?: number): Layer {
  let end = length === undefined ? reader.len : reader.pos + length;
  const message = {} as Layer;
  while (reader.pos < end) {
    const tag = reader.uint32();
    switch (tag >>> 3) {
      case 15:
      message.version = reader.uint32();
      break;
      case 1:
      message.name = reader.string();
      break;
      case 2:
      message.features = decodeTile_Feature(reader, reader.uint32());
      break;
      case 3:
      message.keys = reader.string();
      break;
      case 4:
      message.values = decodeTile_Value(reader, reader.uint32());
      break;
      case 5:
      message.extent = reader.uint32();
      break;
      default:
      reader.skipType(tag & 7);
      break;
    }
  }
  return message;
}

export function encodeLayer(message: Layer, writer: Writer = new Writer()): Writer {
  writer.uint32(120).uint32(message.version);
  writer.uint32(10).string(message.name);
  encodeTile_Feature(message.features, writer.uint32(18).fork()).ldelim();
  writer.uint32(26).string(message.keys);
  encodeTile_Value(message.values, writer.uint32(34).fork()).ldelim();
  writer.uint32(40).uint32(message.extent);
  return writer;
}

export interface Tile_Layer {

  version: number;

  name: string;

  features: Array<Tile_Feature>;

  keys: Array<string>;

  values: Array<Tile_Value>;

  extent: number;

}

export function decodeTile(reader: Reader, length?: number): Tile {
  let end = length === undefined ? reader.len : reader.pos + length;
  const message = {} as Tile;
  while (reader.pos < end) {
    const tag = reader.uint32();
    switch (tag >>> 3) {
      case 3:
      message.layers = decodeTile_Layer(reader, reader.uint32());
      break;
      default:
      reader.skipType(tag & 7);
      break;
    }
  }
  return message;
}

export function encodeTile(message: Tile, writer: Writer = new Writer()): Writer {
  encodeTile_Layer(message.layers, writer.uint32(26).fork()).ldelim();
  return writer;
}

export interface Tile {

  layers: Array<Tile_Layer>;

}
"
`;
